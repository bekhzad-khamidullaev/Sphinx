version: '3.9'

services:
  db:
    image: postgres:15-alpine # Use specific versions
    container_name: sphinx_prod_postgres_db
    volumes:
      - postgres_prod_data:/var/lib/postgresql/data/ # Named volume for persistence
    env_file: .env # Load credentials from .env
    environment:
      # Pass necessary variables for PostgreSQL container setup
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    restart: unless-stopped
    healthcheck:
      # Use $$ for variable expansion within CMD-SHELL
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -q"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - sphinx-net # Attach to custom network

  redis: # Optional: Uncomment if using Redis
    image: redis:7-alpine
    container_name: sphinx_prod_redis
    volumes:
      - redis_prod_data:/data
    restart: unless-stopped
    healthcheck:
       test: ["CMD", "redis-cli", "ping"]
       interval: 5s
       timeout: 2s
       retries: 5
    networks:
      - sphinx-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: sphinx_prod_django_app
    # Production command using Gunicorn + Uvicorn workers
    # Adjust workers (-w) based on server CPU cores (e.g., 2*cores + 1)
    # Ensure 'config.asgi:application' points to your ASGI app instance
    command: gunicorn config.asgi:application -k uvicorn.workers.UvicornWorker -w 4 -b 0.0.0.0:8000 --log-level info --access-logfile - --error-logfile -
    volumes:
      # Mount volumes for static and media files served by Nginx
      - static_volume:/app/staticfiles
      - media_volume:/app/mediafiles
      # Optionally mount code for development ease, but not ideal for production image purity
      # - .:/app
    env_file: .env
    depends_on:
      db:
        condition: service_healthy # Wait for DB to be ready
      redis: # Uncomment if using Redis
        condition: service_healthy
    restart: unless-stopped
    networks:
      - sphinx-net
    # No 'ports' mapping here, Nginx handles external connections

  nginx:
    image: nginx:stable-alpine
    container_name: sphinx_prod_nginx
    ports:
      - "80:80"   # External HTTP -> Nginx container port 80
      - "443:443" # External HTTPS -> Nginx container port 443
    volumes:
      # Mount Nginx config (read-only)
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # Mount static and media volumes (read-only for Nginx)
      - static_volume:/app/staticfiles:ro
      - media_volume:/app/mediafiles:ro
      # Mount Certbot directories for SSL certs (read-only)
      - ./certbot/conf:/etc/letsencrypt:ro
      - ./certbot/www:/var/www/certbot:ro
    depends_on:
      - app # Nginx needs the app service to proxy to
    restart: unless-stopped
    networks:
      - sphinx-net

  certbot: # Service to manage Let's Encrypt certificates
    image: certbot/certbot
    container_name: sphinx_prod_certbot
    volumes:
      # Mount volumes with read-write access for Certbot
      - ./certbot/conf:/etc/letsencrypt:rw
      - ./certbot/www:/var/www/certbot:rw
    # Command to attempt renewal every 12 hours
    # It relies on the webroot challenge via the volume shared with Nginx
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    networks:
      - sphinx-net

  # --- Optional Celery Services ---
  # celery_worker:
  #   build: .
  #   container_name: sphinx_prod_celery_worker
  #   command: celery -A config worker -l INFO # Adjust 'config' if needed
  #   volumes:
  #     - media_volume:/app/mediafiles
  #     # Mount code if not baked into image for worker
  #     # - .:/app
  #   env_file: .env
  #   depends_on:
  #     db: { condition: service_healthy }
  #     redis: { condition: service_healthy }
  #   restart: unless-stopped
  #   networks:
  #     - sphinx-net

  # celery_beat:
  #   build: .
  #   container_name: sphinx_prod_celery_beat
  #   command: celery -A config beat -l INFO --scheduler django_celery_beat.schedulers:DatabaseScheduler # Requires django-celery-beat
  #   env_file: .env
  #   depends_on:
  #     db: { condition: service_healthy }
  #     redis: { condition: service_healthy }
  #     # app: { condition: service_started } # Optional: wait for app if beat needs it directly
  #   restart: unless-stopped
  #   networks:
  #     - sphinx-net
  # --- End Optional Celery ---

networks:
  sphinx-net: # Define the custom network
    driver: bridge

volumes: # Define named volumes for persistent data
  postgres_prod_data:
  redis_prod_data: # Uncomment if using Redis
  static_volume:
  media_volume: